Find the number of emails received by each user under each built-in email label.
The email labels are: 'Promotion', 'Social', and 'Shopping'.
Output the user along with the number of promotion, social, and shopping mails count,.

df = google_gmail_emails.merge(google_gmail_labels, left_on = 'id', right_on = 'email_id', how = 'inner')
df['shopping'] = df['label'].apply(lambda x : 1  if x  == 'Shopping' else 0)
df['Promotion'] = df['label'].apply(lambda x : 1  if x  == 'Promotion' else 0)
df['Social'] = df['label'].apply(lambda x : 1  if x  == 'Social' else 0)
values = df.groupby('to_user').agg(
    shopping_cnt  = ('shopping', 'sum'),
    Promotion_cnt  = ('Promotion', 'sum'),
    Social_cnt  = ('Social', 'sum')
    ).reset_index()

result = (
    df.pivot_table(
        index='to_user',
        columns='label',
        values='id',
        aggfunc='count',
        fill_value=0
    )
    .reset_index()
)
------------------------------------------------------------------------------------------------------------------

Identify users who have logged at least one activity within 30 days of their registration date.
Your output should include the user’s ID, registration date, and a count of the number of activities 
logged within that 30-day period.
Do not include users who did not perform any activity within this 30-day period.

df = user_profiles.merge(user_activities, on = 'user_id', how = 'inner')
df_30 = df[(df['activity_date'] >= df['signup_date']) & (df['activity_date'] <= df['signup_date'] + pd.Timedelta(days = 30))]
df.groupby(['user_id', 'signup_date'])['activity_type'].size().reset_index(name = 'counts')

------------------------------------------------------------------------------------------------------------------

Redfin helps clients to find agents. Each client will have a unique request_id and each
request_id has several calls. For each request_id, the first call 
is an “initial call” and all the following calls are “update calls”. 
What's the average call duration for all update calls?

redfin_call_tracking = redfin_call_tracking.sort_values(by = ['request_id', 'created_on'])
redfin_call_tracking['is_first_row'] = redfin_call_tracking.groupby('request_id')['created_on'].rank(method = 'first')
df = redfin_call_tracking[redfin_call_tracking['is_first_row'] != 1]
#redfin_call_tracking['rank'] = #.rank(method = 'dense')
df.groupby('request_id')['call_duration'].mean().reset_index()

------------------------------------------------------------------------------------------------------------------
Identify colleges with underweight and overweight athletes. Consider athletes with weight < 180 pounds
as underweight and players with weight > 250 pounds as overweight. Output the college along with the
total number of overweight and underweight players. If the college does not have any underweight/overweight
players, leave the college out of the output. 
You can assume that each athlete's full name is unique on their college.

nfl_combine['full_name'] = nfl_combine['firstname'] + ' ' + nfl_combine['lastname']
nfl_combine['weight'] = pd.to_numeric(
    nfl_combine['weight'], errors='coerce'
)
df  = nfl_combine[(nfl_combine['weight'] < 180) | (nfl_combine['weight'] > 250)]
df['underweight'] = (df['weight'] < 180).astype(int)
df['overweight'] = (df['weight'] > 250).astype(int)
df
df.groupby('college')[['underweight', 'overweight']].sum().reset_index()

------------------------------------------------------------------------------------------------------------------
Find the total monetary value for completed orders by service type for every month. 
Output your result as a pivot 
table where there is a column for month and columns for each service type.

uber_orders.head()
uber_orders['month'] = uber_orders['order_date'].dt.month
df = uber_orders[uber_orders['status_of_order'] == 'Completed']
df.groupby([ 'month', 'service_name'])['monetary_value'].sum().unstack().reset_index()
