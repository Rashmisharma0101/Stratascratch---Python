You are given the list of Facebook friends and the list of Facebook pages that users follow. 
Your task is to create a new recommendation system for Facebook. For each Facebook user, 
find pages that this user doesn't follow but at least one of their friends does.
Output the user ID and the ID of the page that should be recommended to this user.

users_friends.head()
friend_pages = users_friends.merge(
    users_pages,
    left_on='friend_id',
    right_on='user_id',
    how='inner'
)
recommendations = friend_pages.merge(
    users_pages,
    left_on=['user_id_x', 'page_id'],
    right_on=['user_id', 'page_id'],
    how='left',
)
recommendations = recommendations[recommendations['user_id'].isnull()]
recommendations[['user_id_x', 'page_id']].drop_duplicates()

-------------------------------------------------------------------------------------------------------------
Find the customers with the highest daily total order cost between 2019-02-01 and 2019-05-01. 
If a customer had more than one order on a certain day, sum the order costs on a daily basis.
Output each customer's first name, total cost of their items, and the date. 
If multiple customers tie for the highest daily total on the same date, return all of them.

orders_df = orders[orders['order_date'].between('2019-02-01', '2019-05-01') ]
merged = orders_df.merge(customers, right_on = 'id', left_on = 'cust_id', how = 'left')
new = merged.groupby(['cust_id','first_name','order_date'])['total_order_cost'].sum().reset_index()
new['rank'] = new.groupby('order_date')['total_order_cost'].rank(method = 'dense', ascending = False)
new[new['rank'] == 1][['first_name','total_order_cost' , 'order_date']]

-------------------------------------------------------------------------------------------------------------
Calculate the net change in the number of products launched by companies in 2020 compared to 2019.
Your output should include the company names and the net difference.
(Net difference = Number of products launched in 2020 - The number launched in 2019.)

y2019 = car_launches[car_launches['year'] == 2019]
y2020 = car_launches[car_launches['year'] == 2020]
df1  = y2019.groupby('company_name')['product_name'].count().reset_index(name = '2019_count')
df2  = y2020.groupby('company_name')['product_name'].count().reset_index(name = '2020_count')
df = df1.merge(df2, on = 'company_name', how = 'outer')
df['net_diff'] = df['2020_count'] - df['2019_count']
df[['company_name', 'net_diff']]

-------------------------------------------------------------------------------------------------------------
Find wineries producing wines with aromas of plum, cherry, rose, or hazelnut (singular form only). 
To make things simpler,
exclude any wine descriptions that contain the plural forms (ex. cherries).

keywords = r'\b(plum|cherry|rose|hazelnut)\b'
df['rank'] = df['description'].str.contains(keywords, case = False, na = False).astype(int)

-------------------------------------------------------------------------------------------------------------

A group of travelers embark on world tours starting with their home cities. 
Each traveler has an undecided itinerary that evolves over the course of the tour. 
Some travelers decide to abruptly end their journey mid-travel and live in their last destination.
Given the dataset of dates on which they travelled between different pairs of cities,
can you find out how many travellers ended back in their home city? For simplicity, 
you can assume that each traveler made at most one trip between two cities in a day.

df = travel_history.sort_values(['traveler', 'date'])
home_city = df.groupby('traveler').first().reset_index()[['traveler', 'start_city']].rename(columns= {'start_city': 'home_city'})

final_city = (
    df
    .groupby('traveler')
    .last()
    .reset_index()[['traveler', 'end_city']]
    .rename(columns={'end_city': 'final_city'})
)
summary = home_city.merge(final_city, on='traveler')
result = summary[summary['home_city'] == summary['final_city']].shape[0]

# learning - .first -  For each group, return the first row that appears.
First‚Äù is NOT based on date automatically
It is based on current row order in the DataFrame.
-------------------------------------------------------------------------------------------------------------
You have been asked to find the employees with the highest and lowest salary across whole dataset.
Your output should include the employee's ID, salary, and employee's department,
as well as a column salary_type that categorizes the output by:
'Highest Salary' represents the highest salary
'Lowest Salary' represents the lowest salary

high = worker[worker['salary']== worker['salary'].max()]['salary'].values[0]
low = worker[worker['salary']== worker['salary'].min()]['salary'].values[0]

worker['salary_type'] = worker['salary'].apply(lambda x : ('high' if x == high else 'low' if x == low else 0))
worker[worker['salary_type'] != 0][['worker_id', 'salary', 'department']]

ALternate
high = worker['salary'].max()
low = worker['salary'].min()

worker['salary_type'] = worker['salary'].apply(
    lambda x: 'Highest Salary' if x == high
    else 'Lowest Salary' if x == low
    else None
)
worker[worker['salary_type'].notna()][['worker_id', 'salary', 'department']]
---------------------------------------------------------------------------------------------------------------
You have a dataset containing information about wines, including their regions, varieties, and 
prices. Some wines have two regions listed (region_1 and region_2). Calculate the total cost of 
wines for each combination of region and variety, 
using both region columns.
Because there are two regions listed, first combine the data from both region columns, 
making sure to remove any duplicate entries and excluding any records with missing prices or regions. 
Then, sum the prices for each unique combination of region and variety and present the results,
showing the region, variety, and total price. Order the final result from the highest total price to the lowest.

df = winemag_p1[['region_1', 'region_2', 'variety', 'price']].dropna(subset=['price', 'region_1', 'region_2'])
df1 = df[['region_1', 'variety', 'price']].rename(columns={'region_1':'region'})
df2 = df[['region_2', 'variety', 'price']].rename(columns={'region_2':'region'})
df_combined = pd.concat([df1, df2], ignore_index=True)
df_combined = df_combined.drop_duplicates()
result = (
    df_combined
    .groupby(['region', 'variety'])['price']
    .sum()
    .reset_index(name='Total_price')
    .sort_values(by='Total_price', ascending=False)
)
---------------------------------------------------------------------------------------------------------------
Your company operates a VR gaming platform where users can launch and play various virtual reality applications. 
The vr_sessions table records every session initiated by users, capturing when they started an app and when they 
exited. The platform analytics 
team needs to understand app popularity and usage patterns.
Calculate the total number of unique sessions for each VR application. 
A session is identified by a unique session_id. If the same session_id appears multiple times in the table (which can happen due to connection retries or logging issues), count it as only one session by keeping the record with the earliest start_time. Include all applications that have at least one session in your results. Return the app name and the total number of sessions.

Keep only earliest record per session
vr_sessions_earliest = vr_sessions.sort_values('start_time').drop_duplicates(subset='session_id', keep='first')

Count unique sessions per app
result = (
    vr_sessions_earliest
    .groupby('app_name')['session_id']
    .nunique()
    .reset_index(name='total_sessions')
    .sort_values('total_sessions', ascending=False)
)

---------------------------------------------------------------------------------------------------------------
Verify that the first 4 digits are equal to 1415 for all phone numbers. 
Output the number of businesses with a phone number that does not start with 1415.


sf_restaurant_health_violations[
    ~sf_restaurant_health_violations['business_phone_number']
        .astype(str)
        .str.startswith('1415')

---------------------------------------------------------------------------------------------------------------
